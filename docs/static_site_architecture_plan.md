# Static Site Architecture Plan: Frank Dunn - Memoirs of the North

This document outlines the proposed architecture and build process for the "Frank Dunn: Memoirs of the North" website, designed as a static site suitable for hosting on GitHub Pages.

## 1. Goal

Create a production-ready, accessible, responsive static website showcasing the memoirs, leveraging existing content processing scripts and assets, while adhering to the constraints of static hosting.

## 2. Technology Stack

*   **Core:** Static HTML, CSS, Vanilla JavaScript
*   **Styling:** Tailwind CSS (compiled to static CSS during build)
*   **Mapping:** Leaflet.js with Leaflet.markercluster plugin
*   **Timeline:** vis-timeline.js (statically configured) or a simpler custom HTML/CSS timeline
*   **Search:** Fuse.js (client-side)
*   **Build Process:** Python (orchestration script + existing analysis scripts)
*   **Templating:** Jinja2 (or similar Python templating engine)
*   **Image Optimization:** Sharp CLI or a Python imaging library (e.g., Pillow)

## 3. Build Process

A central Python script (e.g., `build.py`) will orchestrate the generation of the static site:

1.  **Extract Chapters:** (Optional, if `book.txt` changes) Run `scripts/extract_chapters.py` to generate `chapters/*.txt`.
2.  **Analyze Content & Generate Assets:** Run `scripts/analyze_chapters.py` and `scripts/analyze_chapter_dates.py`. This uses `llm_analyzer.py` (requiring a configured LLM environment) to produce:
    *   `reports/chapter_summary_report.md` (Summaries, locations, LLM dates, image paths)
    *   `reports/chapter_dates_report.md` (Date analysis and validation)
    *   `assets/images/*.png` (Generated chapter illustrations)
3.  **Parse Reports:** The build script reads and parses the generated `.md` reports to gather structured data for all chapters.
4.  **Generate Search Index:** Create `search-index.json` containing data fields (title, summary, keywords) for Fuse.js client-side search.
5.  **Generate Static HTML:** Use a templating engine (e.g., Jinja2) with the parsed data to generate static HTML files (e.g., `index.html`, `map.html`, `timeline.html`, `chapters/index.html`, `chapters/[slug].html`, etc.) into an output directory (e.g., `dist/`).
6.  **Compile CSS:** Execute the Tailwind CSS CLI build command to generate a single, optimized `styles.css` file based on class usage in templates.
7.  **Optimize Images:** Use Sharp CLI or a Python library to process images from `assets/images/`, creating responsive sizes and modern formats (WebP, AVIF).
8.  **Copy Assets:** Copy all necessary static assets (compiled CSS, JS libraries like Leaflet/Fuse.js, optimized images, chapter audio files, `search-index.json`) to the output directory.

### Build Flow Diagram

```mermaid
graph LR
    A[book.txt] --> B(scripts/extract_chapters.py);
    B --> C[chapters/*.txt];
    C --> D(scripts/analyze_chapters.py);
    C --> E(scripts/analyze_chapter_dates.py);
    D --> F[reports/chapter_summary_report.md];
    D --> G[assets/images/*.png];
    E --> H[reports/chapter_dates_report.md];
    F & H & C & G --> I(build.py / Templating Engine);
    I --> J[search-index.json];
    I --> K[Static HTML Pages];
    I --> L(Tailwind CSS);
    L --> M[styles.css];
    G --> N(Image Optimization);
    N --> O[Optimized Images];
    J & K & M & O --> P[Output Directory (e.g., dist/)];
```

## 4. Feature Adaptations for Static Site

The original dynamic features will be adapted as follows:

*   **Global Layout:** Standard Header/Sidebar/Main layout using HTML and Tailwind CSS. Mobile sidebar drawer and theme toggle implemented with minimal Vanilla JS.
*   **Map (`map.html`):** Leaflet.js map populated with markers generated statically during the build process using coordinates from the summary report. Marker clustering via `Leaflet.markercluster`. Clicking markers links to the corresponding static chapter page. Real-time sync with the timeline is removed.
*   **Timeline (`timeline.html`):** Use `vis-timeline.js` configured with static chapter date data from the reports, or generate a simpler static HTML/CSS timeline representation. Clicking items links to the corresponding static chapter page. Real-time sync with the map is removed.
*   **Chapters Page (`chapters/index.html`):** A static HTML grid of chapter preview cards generated by the build script. Basic client-side filtering/sorting using Vanilla JS is possible. Pagination might involve generating multiple static index pages or using client-side JS to show/hide chapters.
*   **Chapter Detail (`chapters/[slug].html`):** Individual static HTML pages generated for each chapter. Includes full text content, banner illustration, location breadcrumb, image gallery (using a JS Lightbox library), and an HTML5 `<audio>` player for narration with basic JS controls (play/pause/skip).
*   **Search:** Client-side search implemented using Fuse.js and the `search-index.json` generated during the build. A search input in the header triggers the JS search function.
*   **Audio Narration:** Relies on `<slug>-narration.mp3` files existing alongside chapter content. Uses HTML5 `<audio>` element and JS for controls. Real-time transcript highlighting is complex for a static site and will likely be simplified (e.g., displaying the full transcript) or omitted.
*   **Thematic Collections:** Can be implemented by adding theme metadata (manually or via LLM analysis during the build) and generating static theme index pages (`themes/index.html`) and individual theme pages (`themes/[theme-slug].html`) that list relevant chapters.
*   **Performance & A11y:** Achieved through semantic HTML, server-side image optimization (`loading="lazy"`, `srcset`), minimal JavaScript footprint, appropriate ARIA attributes, and careful focus management for accessibility. Lighthouse checks remain a valid target.

## 5. Data Flow Summary

1.  Source `book.txt` is split into `chapters/*.txt`.
2.  Analysis scripts (`analyze_chapters.py`, `analyze_chapter_dates.py`) process `chapters/*.txt` using `llm_analyzer.py` to generate structured data reports (`.md`) and image assets.
3.  The `build.py` script parses these reports and uses the data along with templates to generate the final static HTML, CSS, JS, and optimized assets in the output directory.